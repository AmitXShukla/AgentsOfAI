{"kind":"Article","sha256":"480154c72ab8c15bfebaf5f8e9f1c37b39c4805b25b7cc102b4ca17a0caa05cd","slug":"messages","location":"/content/messages.md","dependencies":[],"frontmatter":{"title":"Messages","content_includes_title":false,"github":"https://github.com/AmitXShukla/AgentsOfAI","numbering":{"title":{"offset":1}},"edit_url":"https://github.com/AmitXShukla/AgentsOfAI/blob/main/content/messages.md","exports":[{"format":"md","filename":"messages.md","url":"/build/messages-27f2fbf593e8a96b7555bb92fa04c7e9.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Solution Design","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"gKjQ1ucWBy"}],"identifier":"solution-design","label":"Solution Design","html_id":"solution-design","implicit":true,"key":"nOhmJKCrli"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"As you can see, our business case involves evolving a solution design. A solution design pattern helps in understanding and managing the AI Agent framework implementation to support your business use case.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"mR62fbIhjz"}],"key":"fTxTKobR9T"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Currently, our agentic framework solution design includes the following agents:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"WZ1ZIT3GoP"}],"key":"EF8jFAcAWy"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":8,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"PTOAgent","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"piAozSzFqU"}],"key":"ElFXWXy1gG"},{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"TaskAgent","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"ErMvkdYG2g"}],"key":"W1h5y5zSyd"},{"type":"listItem","spread":true,"position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"LLMAgent","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"EQ00lrQYgs"}],"key":"sDxS3xzvMC"},{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"ManagerAgent","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"xeZGVPBQ0l"}],"key":"u04X7qaXaL"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"BroadcasterAgent","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"i9V7ZLrtAG"}],"key":"ruovmz0LmK"}],"key":"jT6UpV7CN2"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Each agent exhibits specific behaviors in response to tasks. However, this design is not final, and we may need to add, update, or remove agents as the project progresses.","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"QfNcfNMC1L"}],"key":"TUxrxRgdxm"},{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Even now, the workflow feels tedious, and it’s easy to imagine that as we incorporate additional supporting business processes, the number of agents could spiral into unmanageable chaos.","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"Nt5tj1NjWW"}],"key":"tT5YQMj1DU"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Let’s address a key issue in the design. The behavioral methods within the Routed Agents are essentially methods that react to data and ultimately alter the state or data of an agent based on the message or data received. To improve this, we need a more effective mechanism to manage incoming data—whether it’s from other agents or the agent’s own behavioral response to a task.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"CCsgfrLDk6"}],"key":"l34E1BTeWO"},{"type":"paragraph","position":{"start":{"line":20,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"As a starting point, let’s refer to this incoming and outgoing data as ","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"QItOcvJsB3"},{"type":"inlineCode","value":"messages","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"n5TTf7Tlg9"},{"type":"text","value":". This terminology will help us better conceptualize the flow of information.\nThe next step is to implement a more efficient way to handle these ","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"LGWPwdG8hg"},{"type":"inlineCode","value":"messages","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"sNN0WN7BrR"},{"type":"text","value":", ensuring our agent framework remains scalable and manageable as it evolves.","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"tYOWS0G2AU"}],"key":"ZktPoeTKr6"},{"type":"heading","depth":2,"position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Messages Implementation","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"o6aQ6PWkei"}],"identifier":"messages-implementation","label":"Messages Implementation","html_id":"messages-implementation","implicit":true,"key":"rHauH5sosc"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent\n## Refactor - add dataclass to support message data types\nfrom dataclasses import dataclass\n\n## Refactor: add dataclass to support message data types\n@dataclass\nclass PTOAgentMessages: ## add dataclass to support message data types\n    content: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    def do_something(self, message: PTOAgentMessages) -> None:  ## add type def\n        # fetches available PTO for a given employee\n        print(f\"received message: {message.content}\") ## add type def\n\n    def do_something_more(self, message: PTOAgentMessages) -> None:  ## add type def\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.content}\") ## add type def","position":{"start":{"line":25,"column":1},"end":{"line":47,"column":1}},"key":"c23asef3jb"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n\n## add another messageType \n## this is a huge step, type based message communication is one of the key features\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    def do_something(self, message: PTOAgentMessages) -> None:\n        # fetches available PTO for a given employee\n        print(f\"received message: {message.content}\")\n\n    def do_something_more(self, message: PTOAgentMessages) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.content}\")\n    \n    def do_something_with_document(self, message: PTOAgentImageMessages) -> None:\n                                            ## added another messageType\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url}\")","position":{"start":{"line":49,"column":1},"end":{"line":80,"column":1}},"key":"uSzoLI7cN0"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    def do_something(self, message: PTOAgentMessages) -> None:\n        # fetches available PTO for a given employee\n        print(f\"received message: {message.content} from : {message.source}\")\n                                                        ## print message source\n\n    def do_something_more(self, message: PTOAgentMessages) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.content} from : {message.source}\")\n                                                        ## print message source\n    \n    def do_something_with_document(self, message: PTOAgentImageMessages) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url} from : {message.source}\")\n                                                        ## print message source","position":{"start":{"line":82,"column":1},"end":{"line":115,"column":1}},"key":"JCUqWTm1Mm"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    def on_txt_message_1(self, message: PTOAgentMessages) -> None: ## rename method\n        # fetches available PTO for a given employee\n        print(f\"received message: {message.content} from : {message.source}\")\n\n    def on_txt_message_2(self, message: PTOAgentMessages) -> None: ## rename method\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.content} from : {message.source}\")\n    \n    def on_doc_message(self, message: PTOAgentImageMessages) -> None: ## rename method\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url} from : {message.source}\")","position":{"start":{"line":117,"column":1},"end":{"line":147,"column":1}},"key":"JAFujZvRAf"},{"type":"paragraph","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"children":[{"type":"text","value":"If you pay close attention to this code, you’ll notice that defining separate methods like ","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"kVojTjoWqK"},{"type":"inlineCode","value":"on_txt_message_1","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"scra7G7t4A"},{"type":"text","value":" and ","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"sfQoMrNAcv"},{"type":"inlineCode","value":"on_txt_message_2","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"ncymmesw5h"},{"type":"text","value":" is not good practice. However, since we need two distinct methods to perform different tasks, we can refactor the code to call the appropriate method based on the message type.","position":{"start":{"line":149,"column":1},"end":{"line":149,"column":1}},"key":"fTIC7yoxg7"}],"key":"ISHtlJHYOr"},{"type":"code","lang":"python","value":"# refactor above code to use AutoGen Core framework\n# refactor above code to create use base\n\nfrom autogen_core import RoutedAgent\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n## Refactor code to act on message Type def\n    def on_txt_messages(self, message: PTOAgentMessages):\n        if message.source.startswith(\"Agent_1\"):\n            def on_txt_message_1(self, message: PTOAgentMessages) -> None:\n                # fetches available PTO for a given employee\n                print(f\"received message: {message.content} from : {message.source}\")\n        else:\n            def on_txt_message_2(self, message: PTOAgentMessages) -> None:\n                # udpate PTO for a given employee if approved\n                print(f\"received message: {message.content} from : {message.source}\")\n    \n    def on_doc_message(self, message: PTOAgentImageMessages) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url} from : {message.source}\")","position":{"start":{"line":151,"column":1},"end":{"line":187,"column":1}},"key":"TNKnJSsR3r"},{"type":"paragraph","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"children":[{"type":"text","value":"The agent implementation above seems fine to me; however, there’s still one unresolved issue. While we can refactor our other agents (e.g., TaskAgent, LLMAgent, etc.), we haven’t fully addressed the message communication problem.","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"rH2TUG63ms"}],"key":"Ty5wUDC7yq"},{"type":"paragraph","position":{"start":{"line":191,"column":1},"end":{"line":191,"column":1}},"children":[{"type":"text","value":"All these messages are essentially behavioral methods of the Agent class. What we need are asynchronous methods.","position":{"start":{"line":191,"column":1},"end":{"line":191,"column":1}},"key":"nsO3DlTJ7r"}],"key":"Btex0gEkfQ"},{"type":"paragraph","position":{"start":{"line":193,"column":1},"end":{"line":193,"column":1}},"children":[{"type":"text","value":"The reason is that, in a real-world scenario, thousands of users will access this same Agent Framework with different datasets. Creating numerous instances or objects of these agents across many threads is still manageable, but these methods need to be asynchronous.","position":{"start":{"line":193,"column":1},"end":{"line":193,"column":1}},"key":"al37Jz80lV"}],"key":"y5RFQ3KhZU"},{"type":"paragraph","position":{"start":{"line":195,"column":1},"end":{"line":195,"column":1}},"children":[{"type":"text","value":"For example, one agent might be performing deep research, while others are handling simple LLM inferences or accessing API results. Managing these as asynchronous data operations would be far more efficient.","position":{"start":{"line":195,"column":1},"end":{"line":195,"column":1}},"key":"OGJpK7pNBv"}],"key":"bknJRPephD"},{"type":"paragraph","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"children":[{"type":"text","value":"To achieve this, I have a choice: I can start implementing ","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"ZecC5ABiGl"},{"type":"inlineCode","value":"asyncio","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"TeT8BJOKY7"},{"type":"text","value":" and make these methods ","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"MXNMnrUpda"},{"type":"inlineCode","value":"async","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"xL3rXADQTC"},{"type":"text","value":". Let’s go back to the ","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"HXRiBLa6EG"},{"type":"inlineCode","value":"AutoGen Core","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"SvQ43jWAji"},{"type":"text","value":" and explore how we can leverage pre-existing code to refactor this implementation and make these operations asynchronous.","position":{"start":{"line":197,"column":1},"end":{"line":197,"column":1}},"key":"sPXuqx41kJ"}],"key":"ubShhhdT9h"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent, message_handler ## import message handler for async\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    @message_handler ## add async\n    async def on_txt_messages(self, message: PTOAgentMessages): ## add async\n        if message.source.startswith(\"Agent_1\"):\n            async def on_txt_message_1(self, message: PTOAgentMessages) -> ## add async\n                # fetches available PTO for a given employee\n                print(f\"received message: {message.content} from : {message.source}\")\n        else:\n            async def on_txt_message_2(self, message: PTOAgentMessages) -> ## add async\n                # udpate PTO for a given employee if approved\n                print(f\"received message: {message.content} from : {message.source}\")\n    \n    @message_handler ## add async\n    async def on_doc_message(self, message: PTOAgentImageMessages) -> ## add async\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url} from : {message.source}\")","position":{"start":{"line":199,"column":1},"end":{"line":233,"column":1}},"key":"KGLfIAwwWI"},{"type":"paragraph","position":{"start":{"line":235,"column":1},"end":{"line":235,"column":1}},"children":[{"type":"text","value":"There’s still one small improvement we can make to this code to enhance its efficiency.","position":{"start":{"line":235,"column":1},"end":{"line":235,"column":1}},"key":"nP0NZNP6jG"}],"key":"arNnwevYdj"},{"type":"paragraph","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"children":[{"type":"text","value":"Instead of using an ","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"d2mHulIrNB"},{"type":"inlineCode","value":"if:else","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"C2xOgxmwUw"},{"type":"text","value":" statement inside the ","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"pS3p8ESgBN"},{"type":"inlineCode","value":"txt_messages","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"gfx5rMkUtI"},{"type":"text","value":" method, we can leverage the ","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"kxxiTA0y5W"},{"type":"inlineCode","value":"message handler","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"X95PTxLHuR"},{"type":"text","value":" decorator directly.","position":{"start":{"line":237,"column":1},"end":{"line":237,"column":1}},"key":"spxUwVDI8B"}],"key":"RuOgCZUuwC"},{"type":"paragraph","position":{"start":{"line":239,"column":1},"end":{"line":239,"column":1}},"children":[{"type":"text","value":"Another benefit of this approach is that agents passing messages to each other won’t need to know the specific methods. The message handler will automatically process the messages and call the appropriate method based on the message type itself.","position":{"start":{"line":239,"column":1},"end":{"line":239,"column":1}},"key":"gw2tsW8xbr"}],"key":"DBfP0FZc6j"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent, message_handler,\n                 MessageContext ## import message context\nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    ## add message type handler using match\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_1\"))\n    ## add message context\n    async def on_txt_message_1(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # fetches available PTO for a given employee\n        print(f\"received message: {message.content} from : {message.source}\")\n    \n    ## add message type handler using match\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_2\"))\n    ## add message context\n    async def on_txt_message_2(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.content} from : {message.source}\")\n    \n    @message_handler\n    ## add message context\n    async def on_doc_message(self, message: PTOAgentImageMessages, ctx: MessageContext) -> None:\n        # udpate PTO for a given employee if approved\n        print(f\"received message: {message.url} from : {message.source}\")","position":{"start":{"line":241,"column":1},"end":{"line":280,"column":1}},"key":"oKd5H57Xy4"},{"type":"paragraph","position":{"start":{"line":282,"column":1},"end":{"line":282,"column":1}},"children":[{"type":"text","value":"Let’s add one more feature called Agent ID. For now, think of Agent ID as a simple identifier. It’s a broader concept, and we’ll explore it in more detail in a later section. For the time being, let’s just consider Agent ID as an identifier.","position":{"start":{"line":282,"column":1},"end":{"line":282,"column":1}},"key":"wkXgnA7On3"}],"key":"HQq148WEsc"},{"type":"code","lang":"python","value":"## import AgentId\nfrom autogen_core import RoutedAgent, message_handler, MessageContext, AgentId \nfrom dataclasses import dataclass\n\n@dataclass\nclass PTOAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass PTOAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass PTOAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"PTOAgent\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_1\"))\n    async def on_txt_message_1(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # fetches available PTO for a given employee\n         ## added agent ID\n        print(f\"{self.id.type} received message: {message.content} from : {message.source}\")\n    \n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_2\"))\n    async def on_txt_message_2(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # udpate PTO for a given employee if approved\n         ## added agent ID\n        print(f\"{self.id.type} received message: {message.content} from : {message.source}\")\n    \n    @message_handler\n    async def on_doc_message(self, message: PTOAgentImageMessages, ctx: MessageContext) -> None:\n        # udpate PTO for a given employee if approved\n         ## added agent ID\n        print(f\"{self.id.type} received message: {message.url} from : {message.source}\")","position":{"start":{"line":284,"column":1},"end":{"line":321,"column":1}},"key":"kBE4nvuvjm"},{"type":"paragraph","position":{"start":{"line":323,"column":1},"end":{"line":323,"column":1}},"children":[{"type":"text","value":"now we have a complete Agent implementation, but we need to create more such agents.","position":{"start":{"line":323,"column":1},"end":{"line":323,"column":1}},"key":"sB5HYyCTYx"}],"key":"rSSF2q6fB8"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":325,"column":1},"end":{"line":330,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":325,"column":1},"end":{"line":325,"column":1}},"children":[{"type":"text","value":"PTOAgent","position":{"start":{"line":325,"column":1},"end":{"line":325,"column":1}},"key":"U1yfNN9nzE"}],"key":"OmN20VwVUG"},{"type":"listItem","spread":true,"position":{"start":{"line":326,"column":1},"end":{"line":326,"column":1}},"children":[{"type":"text","value":"TaskAgent","position":{"start":{"line":326,"column":1},"end":{"line":326,"column":1}},"key":"ybrFRYslx8"}],"key":"osCU9PaTOW"},{"type":"listItem","spread":true,"position":{"start":{"line":327,"column":1},"end":{"line":327,"column":1}},"children":[{"type":"text","value":"LLMAgent","position":{"start":{"line":327,"column":1},"end":{"line":327,"column":1}},"key":"lXGCw5CG0U"}],"key":"jwUBZzYcbS"},{"type":"listItem","spread":true,"position":{"start":{"line":328,"column":1},"end":{"line":328,"column":1}},"children":[{"type":"text","value":"ManagerAgent","position":{"start":{"line":328,"column":1},"end":{"line":328,"column":1}},"key":"bwCeDONB3B"}],"key":"H7NT6OVqny"},{"type":"listItem","spread":true,"position":{"start":{"line":329,"column":1},"end":{"line":330,"column":1}},"children":[{"type":"text","value":"BroadcasterAgent","position":{"start":{"line":329,"column":1},"end":{"line":329,"column":1}},"key":"LiR60eF2Vg"}],"key":"zzEZgEg6a7"}],"key":"tEY8XOcfSu"},{"type":"paragraph","position":{"start":{"line":331,"column":1},"end":{"line":332,"column":1}},"children":[{"type":"text","value":"for the sake of simplicity, for now, let’s just focus on one more agent, say TaskAgent, we will deal with LLM Type agents later.\nLet’s build Task Agent.","position":{"start":{"line":331,"column":1},"end":{"line":331,"column":1}},"key":"clmoTyOcj9"}],"key":"vgnXgY5JCj"},{"type":"code","lang":"python","value":"from autogen_core import RoutedAgent, message_handler, MessageContext, AgentId\nfrom dataclasses import dataclass\n\n@dataclass\nclass TaskAgentMessages:\n    content: str\n    source: str\n\n@dataclass\nclass TaskAgentImageMessages:\n    url: str\n    source: str\n\nfrom autogen_core import RoutedAgent\nclass TaskAgent(RoutedAgent):\n    def __init__(self) -> None:\n        super().__init__(\"TaskAgent\")\n\n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_1\"))\n    async def on_txt_message_1(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # fetches tasks an employee\n        print(f\"{self.id.type} received message: {message.content} from : {message.source}\")\n    \n    @message_handler(match=lambda msg, ctx: msg.source.startswith(\"Agent_2\"))\n    async def on_txt_message_2(self, message: PTOAgentMessages, ctx: MessageContext) -> None:\n        # poeple working on one task \n        print(f\"{self.id.type} received message: {message.content} from : {message.source}\")\n    \n    @message_handler\n    async def on_doc_message(self, message: PTOAgentImageMessages, ctx: MessageContext) -> None:\n        # fetch all other teams working on same tasks and their PTO during same period\n        print(f\"{self.id.type} received message: {message.url} from : {message.source}\")","position":{"start":{"line":334,"column":1},"end":{"line":367,"column":1}},"key":"ud8W6yuZm2"}],"key":"libqOFnniY"}],"key":"H6YaYwH9Ak"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Agent","url":"/implementation","group":"AutoGen Core"},"next":{"title":"Runtime","url":"/runtime","group":"AutoGen Core"}}},"domain":"http://localhost:3001"}